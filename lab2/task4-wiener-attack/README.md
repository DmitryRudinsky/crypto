# Task 4: Wiener Attack on RSA

## Описание

Сервис для выполнения атаки Винера на открытый ключ RSA. Атака позволяет найти закрытую экспоненту d, если она мала (d < n^(1/4)).

## Принцип атаки Винера

Атака основана на том, что если d < n^(1/4), то d можно найти через разложение e/n в цепную дробь и вычисление подходящих дробей.

**Условие уязвимости:** d < n^(1/4)

**Математическая основа:**
- k/d ≈ e/n для некоторого целого k
- k/d является одной из подходящих дробей разложения e/n в цепную дробь
- Из соотношения e*d ≡ 1 (mod φ(n)) следует: e*d - 1 = k*φ(n)
- Отсюда: φ(n) = (e*d - 1) / k

## Архитектура

### WienerAttackService

**Вложенные классы:**

`Fraction` - представление подходящей дроби:
- `numerator` - числитель (k)
- `denominator` - знаменатель (d)

`AttackResult` - результат атаки:
- `d` - найденная закрытая экспонента
- `phi` - найденное значение функции Эйлера φ(n)
- `convergents` - коллекция всех вычисленных подходящих дробей
- `success` - флаг успешности атаки

**Основной метод:**

`attack(BigInteger e, BigInteger n)` → `AttackResult`

## Алгоритм атаки

### 1. Вычисление цепной дроби
Разложение e/n в цепную дробь [a₀; a₁, a₂, ...]:
```
e/n = a₀ + 1/(a₁ + 1/(a₂ + ...))
```

Алгоритм Евклида:
```
while b ≠ 0:
    q = a / b
    добавить q в цепную дробь
    (a, b) = (b, a mod b)
```

### 2. Вычисление подходящих дробей (convergents)
Для цепной дроби [a₀; a₁, a₂, ...] вычисляем последовательность подходящих дробей k/d:

**Начальные значения:**
- h₀ = a₀, k₀ = 1
- h₁ = a₀*a₁ + 1, k₁ = a₁

**Рекуррентная формула:**
- hᵢ = aᵢ*hᵢ₋₁ + hᵢ₋₂
- kᵢ = aᵢ*kᵢ₋₁ + kᵢ₋₂

Каждая дробь hᵢ/kᵢ является подходящей дробью.

### 3. Проверка каждой подходящей дроби
Для каждой подходящей дроби k/d:

1. Вычислить φ = (e*d - 1) / k
2. Проверить валидность φ:
   - φ > 0
   - φ < n
3. Проверить e*d ≡ 1 (mod φ)
4. Верифицировать через шифрование/дешифрование:
   - Зашифровать тестовое сообщение: c = m^e mod n
   - Расшифровать найденным d: m' = c^d mod n
   - Проверить m' = m

### 4. Возврат результата
Если найдена корректная пара (d, φ), возвращается успешный результат со всеми подходящими дробями.

## Вспомогательный класс

### VulnerableRSAGenerator

Генератор уязвимых RSA ключей для тестирования атаки.

**Метод:** `generateVulnerableKeyPair(int bitLength)` → `KeyPair`

**Алгоритм:**
1. Генерация двух простых чисел p и q заданной битовой длины
2. Вычисление n = p*q, φ = (p-1)*(q-1)
3. Вычисление порога: threshold = n^(1/4)
4. Генерация малого d < threshold, взаимно простого с φ
5. Вычисление e из d: e ≡ d^(-1) (mod φ)

**Возвращает:**
- `n` - модуль
- `e` - открытая экспонента
- `d` - закрытая экспонента (уязвимая)
- `p, q` - простые множители
- `phi` - функция Эйлера

## Тесты

`WienerAttackTest.java` - 884 теста (из-за проверки каждой подходящей дроби):

**testSmallVulnerableKey** (3 теста):
- Атака успешна на уязвимом 128-битном ключе
- Найденное d совпадает с реальным
- Найденное φ совпадает с реальным

**testMultipleVulnerableKeys** (4 теста):
- Атака на 128-битные ключи
- Атака на 256-битные ключи
- Проверка корректности найденного d для каждого размера

**testConvergentsComputation** (много тестов):
- Список подходящих дробей не пустой
- Все подходящие дроби имеют корректную структуру
- Числители и знаменатели не null
- Знаменатели положительные
- Проверка для каждой вычисленной дроби (~300 дробей)

**testAttackResultStructure** (6 тестов):
- При успехе d и φ не null
- d и φ положительные
- Список convergents не пустой

**testDecryptionVerification** (3 теста):
- Проверка дешифрования сообщения 42
- Проверка дешифрования сообщения 12345
- Проверка дешифрования сообщения 999

**testKnownVulnerableKey** (5 тестов):
- Атака на известный уязвимый ключ (n=90581, e=17993)
- Проверка нахождения d и φ
- Проверка условия e*d ≡ 1 (mod φ)
- Проверка корректности дешифрования

Все тесты проходят успешно.

## Демонстрация

`Demo.java` - комплексная демонстрация атаки:

**1. Генерация уязвимого ключа**
- Создание 256-битного уязвимого RSA ключа
- Вывод параметров: n, e, d, φ
- Вывод битовых длин n и d
- Демонстрация условия d < n^(1/4)

**2. Выполнение атаки Винера**
- Запуск атаки на сгенерированный ключ
- Вывод найденных d и φ
- Проверка совпадения с реальными значениями

**3. Подходящие дроби**
- Вывод общего количества вычисленных convergents
- Вывод первых 10 подходящих дробей в формате k/d

**4. Верификация результата**
- Шифрование тестового сообщения 123456
- Дешифрование найденным d
- Проверка корректности

**5. Тест на разных размерах ключей**
- Атака на 128-битные ключи
- Атака на 256-битные ключи
- Атака на 512-битные ключи
- Для каждого: вывод битовых длин, успешности, количества convergents

**6. Известный уязвимый пример**
- Атака на известные параметры (n=90581, e=17993)
- Демонстрация нахождения d=5
- Верификация через шифрование/дешифрование

## Сложность атаки

**Временная сложность:** O(log n)
- Вычисление цепной дроби: O(log n)
- Вычисление подходящих дробей: O(log n)
- Проверка каждой дроби: O(log n)

**Количество подходящих дробей:** ~log₂(n)

Для 512-битного модуля вычисляется ~300 подходящих дробей.

## Защита от атаки

Для защиты от атаки Винера необходимо:
1. Использовать d > n^(1/4)
2. Обычно достаточно d > n^(1/3) для надежности
3. Проверять условие при генерации ключей (как в task3-rsa)

## Запуск

```bash
./run-demo.sh   # сборка + запуск демонстрации
./run-tests.sh  # сборка + запуск тестов
./build.sh      # только сборка
```

## Структура

```
lib-src/
  NumberTheoryService.java  - операции теории чисел

src/
  WienerAttackService.java      - сервис атаки Винера
  VulnerableRSAGenerator.java   - генератор уязвимых ключей
  Demo.java                     - демонстрация

test/
  WienerAttackTest.java  - тесты

out/
  production/  - скомпилированные классы
  test/        - скомпилированные тесты
```

## Практическое применение

Атака Винера демонстрирует важность правильного выбора параметров RSA:
- Малое d ускоряет дешифрование, но делает систему уязвимой
- Необходим баланс между производительностью и безопасностью
- Современные реализации проверяют размер d при генерации ключей

## Примеры результатов

**Успешная атака на 256-битный ключ:**
- n: 511 бит
- d: 126 бит (уязвимый)
- n^(1/4): 128 бит
- Условие d < n^(1/4): выполнено
- Convergents: 292
- Атака: SUCCESS

**Успешная атака на известный пример:**
- n: 90581
- e: 17993
- Найдено d: 5
- Найдено φ: 89964
- Convergents: 9
- Атака: SUCCESS

